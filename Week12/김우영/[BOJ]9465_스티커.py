# 웹 서핑을 통해 블로그 참조 하였읍니다.

# 출처: https://galid1.tistory.com/507
# DP(동적 계획법): 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 알고리즘 설계 기법
# 피보나치 재귀 코드랑 DP 코드 보면 어떤 느낌인지 대충 이해됨


T = int(input())

for _ in range(T):
    n = int(input()) # 열의 개수
    
    arr = [list(map(int, input().split())) for _ in range(2)]
    
    # 동일한 크기의 DP 배열 생성
    # DP[x][y] = 규칙을 따라 해당 지점(x, y)까지 갈 수 있는 최대 값이 담김 (본 문제 규칙: 선택한 스티커를 기준으로 상하좌우는 못감)
    # 즉, DP[i][n] == n열에서 i행 스티커를 마지막으로 골랐을 때의 최대가치
    # so, 문제 답은 DP[0][-1]과 DP[1][-1] 중 최대값임

    DP = [[0] * (n) for _ in range(2)]


    # 1. n이 1인 경우 -> 위 아래 둘 중 큰 거 고르면 댐
    DP[0][0], DP[1][0] = arr[0][0], arr[1][0]
    if n == 1:
        print(max(DP[0][0], DP[1][0]))
        continue # 반복문 탈출


    # 2. n이 2인 경우 -> 위에서 출발하고 아래 대각선 방향 합한 값과 아래에서 출발하고 위 대각선 방향 합한 값 중 큰 거 고르면 댐
    DP[0][1] = arr[1][0] + arr[0][1]
    DP[1][1] = arr[0][0] + arr[1][1]
    if n == 2:
        print(max(DP[0][1], DP[1][1]))
        continue
    

    # 3. n이 3 이상인 경우
    # 마지막 값은 무조건 더해야댐 (그래야 무조건 최대가 나옴)
    # 근데 마지막 값 기준 다른 행의 바로 앞 열과 같은 행의 바로 앞 앞 열 중 큰 값을 골라야 함
    
    for i in range(2, n):
        DP[0][i] = max(DP[1][i-2], DP[1][i-1]) + arr[0][i]
        DP[1][i] = max(DP[0][i-2], DP[0][i-1]) + arr[1][i]

    print(max(DP[0][n-1], DP[1][n-1]))